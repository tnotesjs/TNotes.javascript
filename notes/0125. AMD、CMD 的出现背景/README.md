# [0125. AMD、CMD 的出现背景](https://github.com/tnotesjs/TNotes.javascript/tree/main/notes/0125.%20AMD%E3%80%81CMD%20%E7%9A%84%E5%87%BA%E7%8E%B0%E8%83%8C%E6%99%AF)

<!-- region:toc -->

- [1. 🎯 本节内容](#1--本节内容)
- [2. 🫧 评价](#2--评价)
- [3. 🧠 CommonJS 在 nodejs 端表现良好，但无法适用于浏览器端](#3--commonjs-在-nodejs-端表现良好但无法适用于浏览器端)
  - [3.1. nodejs 环境](#31-nodejs-环境)
  - [3.2. 浏览器环境](#32-浏览器环境)
  - [3.3. 小结](#33-小结)
- [4. 🤔 AMD 和 CMD 为什么会出现？](#4--amd-和-cmd-为什么会出现)
- [5. 🤔 CommonJS 那一套搬运到浏览器中使用的核心问题是什么？](#5--commonjs-那一套搬运到浏览器中使用的核心问题是什么)
- [6. 🤔 AMD、CMD 是什么？](#6--amdcmd-是什么)

<!-- endregion:toc -->

## 1. 🎯 本节内容

- AMD、CMD 的出现背景
- CommonJS 的适用场景

## 2. 🫧 评价

- 重点在于理解为何类似于 AMD、CMD 这样作用于浏览器端的模块化规范会出现。
- AMD、CMD 是「早期」应用于浏览器端的模块化规范，它们是社区标准，并非官方标准。
  - 官方标准是 ESM。
  - AMD、CMD 比 ESM 出现得更早。
- 本节笔记主要解答以下问题：
  - 那么为什么 node 端的 CommonJS 不能直接搬到浏览器端来用呢？它们不都是 JS 吗？为啥还要整出个 AMD、CMD？
  - AMD、CMD 是如何解决模块隔离的呢？
  - AMD、CMD 是如何解决模块同步加载问题的呢？
- 结尾记录了一些思考题，以加深理解。

## 3. 🧠 CommonJS 在 nodejs 端表现良好，但无法适用于浏览器端

### 3.1. nodejs 环境

- 当使用 `require(模块路径)` 导入一个模块时，如果这个模块没有被加载过，还没有被缓存，那么 node 会做以下两件事情：
  1. 通过模块路径找到本机文件，并读取文件内容。
  2. 将文件中的代码放入到一个函数环境中执行，并将执行后 `module.exports` 的值作为 `require函数` 的返回结果。
- 可以认为上述这两个步骤是 **同步** 的，必须要等到加载完文件并执行完代码后才能继续向后执行。
- 即 `require` 函数会 **阻塞** 代码执行，直到模块被完全加载和执行完毕。
- 这意味着在模块代码执行完成之前，后续的代码不会执行。

### 3.2. 浏览器环境

- 当想要把 CommonJS 放到浏览器端时，就遇到了一些挑战。
  1. 浏览器要加载 JS 文件，需要远程从服务器读取，而网络传输的效率远远低于 node 环境中读取本地文件的效率。
     - 在服务端，很多时候都不需要将所有模块 build 到一个或若干个文件中，而是直接通过入口启动，然后按需加载模块。
     - 在浏览器端，当模块数量过多时，从服务端读取大量模块的耗时会明显大于本地文件 IO 的耗时。
  2. 加上 CommonJS 的模块导入执行流程是同步的，这会极大的影响用户体验，在加载模块期间，甚至会导致浏览器页面卡死。
  3. 如果需要读取 JS 文件内容并把它放入到一个环境中执行，需要浏览器厂商的支持，可是浏览器厂商不愿意提供支持，最大的原因是 CommonJS 属于社区标准，并非官方标准。
- 浏览器端使用 CommonJS 的核心痛点：**模块同步加载问题**。
- 综上，CommonJS 这一社区规范并不适合直接丢到浏览器端来使用。
- 要在浏览器中实现模块化，需要解决以下问题：
  - 模块数量太多的话，网络通信耗时忒长 👉 可以打包到一个或若干个文件中解决
  - 模块的同步加载导致页面卡死 👉 采用异步加载的方案来解决
  - 并非社区标准 👉 需要官方发话解决
- 在官方发话之前，出现了类似 AMD、CMD 规范，它们实现模块化的做法思路大致是：
  - 模块同步加载的问题：模块的加载，做成异步即可，加载完成后调用一个回调就行了。
  - 不同模块需要隔离的问题：
    - CommonJS 在解析模块的时候会自动将模块代码放入到一个函数中执行，然后返回模块导出的结果。
    - 浏览器端：在编写模块时，直接放函数中就行了，没人帮忙包裹一层，就自己包一层。
  - 基于这种简单有效的思路，率先出现了 AMD 和 CMD 规范，它们有效地解决了浏览器模块化的问题。

### 3.3. 小结

- 服务端：**CommonJS 这种模块同步加载机制在服务器端编程中是可行的，因为速度很快，几乎不会影响到用户体验**。
- 浏览器端：**在浏览器端，这种同步加载会导致严重的体验问题**。

## 4. 🤔 AMD 和 CMD 为什么会出现？

- AMD 和 CMD 的出现是社区为了解决 CommonJS **同步加载** 机制在浏览器端所带来的性能和用户体验问题而产生的。
- AMD 和 CMD 的出现，填补了在官方 **ESM (ECMAScript Modules)** 出现之前，浏览器端模块化方案的空白。
  - 它们虽然在实现细节上有所不同，但都成功地将模块加载从同步模式转为异步模式，有效地解决了 CommonJS 在浏览器端的核心痛点。
  - 随着 ECMAScript 2015（ES6）的发布，官方的 ESM 标准已经成为主流，它结合了 AMD 和 CMD 的优点，提供了简洁的语法和强大的功能，这使得 AMD 和 CMD 这类社区规范逐渐退出了历史舞台。
  - 可以把 AMD 和 CMD 的出现背景理解为，在官方（W3C 或 TC39）标准 ESM 出现之前，JavaScript 社区为了在浏览器端实现模块化而进行的探索和尝试。

## 5. 🤔 CommonJS 那一套搬运到浏览器中使用的核心问题是什么？

- CommonJS 规范是为服务器端设计的，其 **同步加载** 模块的方式依赖于本地文件系统的高速 I/O。但在浏览器端，模块需要通过网络请求来获取。如果使用同步加载，浏览器会 **阻塞**，直到所有模块都下载完成，这会导致页面长时间卡死，用户体验极差。

## 6. 🤔 AMD、CMD 是什么？

- AMD、CMD 是两种不同的 **异步模块加载方案**
- **AMD (Asynchronous Module Definition)**：
  - **代表实现：** RequireJS
  - **核心思想：** **依赖前置**。
    - 它要求开发者在定义模块时，就要声明所有依赖的模块。
    - 加载器会并行地异步下载所有依赖，当所有依赖都加载完成后，才会执行当前模块的回调函数。
  - **优点：** 提前加载依赖，可以并行处理，性能较好。
  - **缺点：** 依赖关系必须提前写好，不够直观，有时会导致不必要的加载。
- **CMD (Common Module Definition)**：
  - **代表实现：** Sea.js
  - **核心思想：** **就近依赖**。
    - 它只在需要使用模块时才进行下载和执行。
  - **优点：** 逻辑清晰，模块加载时机更符合 CommonJS 的语法习惯。
  - **缺点：** 依赖不能并行加载，可能导致 Cascading network requests（级联式网络请求），在网络条件差时，性能表现不如 AMD。
