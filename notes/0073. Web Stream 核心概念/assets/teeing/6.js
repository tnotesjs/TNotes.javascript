// ----------------------------------------
// 🆚 手动分块 vs tee() 分流
// ----------------------------------------

// 1. 手动分块理论可行，但：
//    - 需要手动拷贝每个数据块（2 倍内存）
//    - 没有背压控制（可能内存溢出）
//    - 代码复杂，容易出错
//    - 需要处理很多边界情况
// 2. tee() 的优势：
//    - 自动背压控制（防止内存溢出）
//    - 浏览器内部可能有优化（Copy-on-Write）
//    - 代码简洁，一行搞定
//    - 所有边界情况都已处理
// 3. 性能对比：
//    手动分块：更多的内存拷贝 + 可能的内存溢出
//    tee()：优化的内存使用 + 自动背压控制

// 内存占用对比
// 手动分块：每个块拷贝 2 次（browserChunk + cacheChunk）
// tee()：浏览器内部优化，可能使用 Copy-on-Write，拷贝次数更少

// 代码复杂度
// 手动分块：~40 行代码，需要手动管理 controller
// tee()：1 行代码

// 背压控制
// 手动分块：❌ 没有背压控制！
//   - 如果浏览器读取很快，缓存写入很慢
//   - cacheStream 的内部队列会越来越大
//   - 最终可能导致内存溢出
// tee()：✅ 自动背压控制
//   - 两个流的读取速度会自动协调
//   - 慢的流会让快的流减速

// 错误处理
// 手动分块：需要手动传播错误到两个 controller
// tee()：自动处理

// 边界情况
// 手动分块：需要考虑：
//   - 如果其中一个流被取消怎么办？
//   - 如果读取过程中出错怎么办？
//   - 如何确保两个流的状态同步？
// tee()：所有边界情况都已处理

// ⚠️ 手动分块的关键问题：背压控制

// 场景：浏览器显示视频（快），缓存写入磁盘（慢）

// 手动分块（没有背压）：
// 时间轴：
// T1: 读取 chunk1 → 发给浏览器 ✓ → 发给缓存（排队中）
// T2: 读取 chunk2 → 发给浏览器 ✓ → 发给缓存（排队中）
// T3: 读取 chunk3 → 发给浏览器 ✓ → 发给缓存（排队中）
// ...
// T100: cacheStream 内部队列有 95 个未处理的 chunk
//       内存占用 = 95 × 64KB = 6MB+
//       继续增长... 💥 内存溢出

// tee()（自动背压）：
// T1: 读取 chunk1 → 发给浏览器 ✓ → 发给缓存（排队中）
// T2: 读取 chunk2 → 发给浏览器 ✓ → 发给缓存（排队中）
// T3: cacheStream 内部队列满了 → 发送背压信号
// T4: 暂停读取，等待 cacheStream 消费
// T5: cacheStream 消费了一些 chunk → 继续读取
//     内存占用始终保持在合理范围内 ✅

// 💡 最佳实践：
// 除非有特殊需求，否则使用 tee()
// const [stream1, stream2] = response.body.tee()

// 🎯 结论：
// 可以手动分块拷贝，但这正是 tee() 在做的事
// tee() = 专业的分块拷贝实现 + 背压控制 + 错误处理 + 内存优化
// 手动实现分块拷贝没有意义，只会增加复杂度和 bug
// 使用 tee() 就是在使用"正确的分块拷贝"
