<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script type="module">
      // 一个流分成两个相同的流，同时处理
      const response = await fetch(
        'https://jsonplaceholder.typicode.com/todos/1' // 少量数据
        // 'https://jsonplaceholder.typicode.com/comments' // 大量数据
      )

      // response.body 也是一个 ReadableStream 可读流对象
      // console.log('response.body:', response.body)
      // response.body: ReadableStream {locked: false}

      // tee() 用于将一个流分成两个完全相同的独立流
      // 主要解决“一个数据源需要多个消费者同时处理”的问题
      // ReadableStream 有一个重要特性：一旦被读取，数据就消失了（流只能读一次）
      // 如果你需要对同一份数据做多种处理，就必须用 tee() 分流
      const [stream1, stream2] = response.body.tee()

      // 消费路径1：显示在页面
      // 路径中集成了 TextDecoderStream 解码器
      const displayPromise = stream1
        .pipeThrough(new TextDecoderStream()) // 加入解码器
        .pipeTo(
          new WritableStream({
            write(chunk) {
              console.log('display:', chunk)
              document.body.textContent = chunk
            },
            close() {
              console.log('✅ stream1 closed')
            },
          })
        )

      // 消费路径2：输出到控制台
      // 路径中未集成 TextDecoderStream 解码器
      const logPromise = stream2.pipeTo(
        new WritableStream({
          write(chunk) {
            console.log('解码前的原始字节流数据：')
            console.log('log:', chunk)

            const decoder = new TextDecoder()
            const text = decoder.decode(chunk, { stream: true })
            console.log('解码后的数据：')
            console.log('log:', text)
          },
          close() {
            console.log('✅ stream2 closed')
          },
        })
      )

      // 同一份数据发往了两个不同的目的地
      // 消费路径 1 和消费路径 2 对流的处理流程是不同的
      // 两个流程互相独立，互不影响

      // 等待两个分支都完成
      await Promise.all([displayPromise, logPromise])
    </script>
  </body>
</html>
